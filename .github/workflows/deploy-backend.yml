name: Migrate and Deploy Backend

on:
  push:
    branches: [ main ]

permissions:
  contents: read
  id-token: write
  packages: write

jobs:
  migrate-and-deploy:
    runs-on: ubuntu-latest
    env:
      # These should be configured as repository secrets
      SPRING_DATASOURCE_URL: ${{ secrets.SPRING_DATASOURCE_URL }}
      SPRING_DATASOURCE_USERNAME: ${{ secrets.SPRING_DATASOURCE_USERNAME }}
      SPRING_DATASOURCE_PASSWORD: ${{ secrets.SPRING_DATASOURCE_PASSWORD }}
      KOYEB_API_KEY: ${{ secrets.KOYEB_API_KEY }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Detect backend directory
        run: |
          # Detect whether mvnw is at repo root or inside a backend subfolder and set BACKEND_DIR
          if [ -f "$GITHUB_WORKSPACE/mvnw" ]; then
            echo "BACKEND_DIR=$GITHUB_WORKSPACE" >> $GITHUB_ENV
          elif [ -f "$GITHUB_WORKSPACE/backend/mvnw" ]; then
            echo "BACKEND_DIR=$GITHUB_WORKSPACE/backend" >> $GITHUB_ENV
          else
            echo "Could not find mvnw in workspace." >&2
            exit 1
          fi

      - name: Make mvnw executable
        run: |
          chmod +x "$BACKEND_DIR/mvnw"

      - name: Build backend (skip Flyway in CI)
        working-directory: ${{ env.BACKEND_DIR }}
        run: |
          echo "Building backend JAR (Flyway will run at app startup on Koyeb with proper DB connection)"
          "$BACKEND_DIR/mvnw" -DskipTests package

      - name: Build & push Docker image
        run: |
          # Ensure repository owner is lowercased (GHCR requires lowercase repository names)
          OWNER_LOWER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          IMAGE_BASE=ghcr.io/${OWNER_LOWER}/stockease
          IMAGE_SHA=${IMAGE_BASE}:${{ github.sha }}
          IMAGE_LATEST=${IMAGE_BASE}:latest
          echo "Building and pushing images"
          echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u "${{ github.actor }}" --password-stdin
          docker build -f "$BACKEND_DIR/Dockerfile" -t "$IMAGE_SHA" -t "$IMAGE_LATEST" "$BACKEND_DIR"
          docker push "$IMAGE_SHA"
          docker push "$IMAGE_LATEST"

          # Try to determine the image digest so we can deploy by digest (more robust)
          IMAGE_DIGEST_FULL=""
          # Inspect local image for RepoDigests (may be present after push)
          if docker inspect --format='{{index .RepoDigests 0}}' "$IMAGE_SHA" >/dev/null 2>&1; then
            IMAGE_DIGEST_FULL=$(docker inspect --format='{{index .RepoDigests 0}}' "$IMAGE_SHA" 2>/dev/null || true)
          fi

          # Fallback to GHCR registry API to get Docker-Content-Digest header if inspect failed
          if [ -z "$IMAGE_DIGEST_FULL" ]; then
            echo "Local RepoDigests not available; querying GHCR for manifest digest"
            REPO_PATH=$(echo "$IMAGE_SHA" | sed 's|ghcr.io/||' | sed 's/:.*//')
            TAG=$(echo "$IMAGE_SHA" | awk -F: '{print $NF}')
            # Use GitHub token to query GHCR registry manifest
            DIGEST_HEADER=$(curl -sI -H "Accept: application/vnd.docker.distribution.manifest.v2+json" -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" "https://ghcr.io/v2/$REPO_PATH/manifests/$TAG" | tr -d '\r' | awk -F ': ' '/Docker-Content-Digest/ {print $2}')
            if [ -n "$DIGEST_HEADER" ]; then
              IMAGE_DIGEST_FULL="ghcr.io/$REPO_PATH@$DIGEST_HEADER"
            fi
          fi

          if [ -n "$IMAGE_DIGEST_FULL" ]; then
            echo "Determined image digest: $IMAGE_DIGEST_FULL"
            # Use digest for deploy (preferred)
            echo "IMAGE=$IMAGE_DIGEST_FULL" >> $GITHUB_ENV
            echo "IMAGE_DIGEST=$IMAGE_DIGEST_FULL" >> $GITHUB_ENV
          else
            echo "Could not determine image digest; falling back to tag $IMAGE_SHA"
            echo "IMAGE=$IMAGE_SHA" >> $GITHUB_ENV
          fi

      - name: Install jq
        run: |
          sudo apt-get update && sudo apt-get install -y jq

      - name: Ensure image var is set
        run: |
          if [ -z "${IMAGE:-}" ]; then
            echo "IMAGE not set" >&2; exit 1
          fi

      - name: Wait for image to be available in registry
        env:
          IMAGE: ${{ env.IMAGE }}
        run: |
          echo "Logging into GHCR to verify image availability"
          echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u "${{ github.actor }}" --password-stdin
          MAX_ATTEMPTS=12
          ATTEMPT=0
          SLEEP=5
          until docker pull "$IMAGE"; do
            ATTEMPT=$((ATTEMPT+1))
            if [ "$ATTEMPT" -ge "$MAX_ATTEMPTS" ]; then
              echo "Image $IMAGE not available in registry after $MAX_ATTEMPTS attempts"
              exit 1
            fi
            echo "Image not available yet; retrying attempt $ATTEMPT/$MAX_ATTEMPTS after ${SLEEP}s"
            sleep $SLEEP
          done
          echo "Image $IMAGE is available in registry"

      - name: Deploy to Koyeb via API (no CLI)
        env:
          KOYEB_API_KEY: ${{ secrets.KOYEB_API_KEY }}
          KOYEB_SERVICE_ID: ${{ secrets.KOYEB_SERVICE_ID }} # put this in repo secrets
          IMAGE: ${{ env.IMAGE }}
        run: |
          test -n "$IMAGE" || { echo "IMAGE not set"; exit 1; }
          echo "Checking Koyeb service exists (KOYEB_SERVICE_ID) before attempting deploy..."
          # Verify the service exists and capture response for diagnostics
          SERVICE_CHECK_CODE=$(curl -s -o /tmp/koyeb_service_resp.json -w "%{http_code}" \
            -H "Authorization: Bearer $KOYEB_API_KEY" \
            "https://app.koyeb.com/v1/services/$KOYEB_SERVICE_ID")
          echo "Service check HTTP code: $SERVICE_CHECK_CODE"
          if [ "$SERVICE_CHECK_CODE" -eq 404 ]; then
            echo "ERROR: Koyeb service not found (404). Dumping response body for debugging:" 
            cat /tmp/koyeb_service_resp.json || true
            echo "Please verify the KOYEB_SERVICE_ID repository secret is correct and the service exists in Koyeb."
            exit 1
          fi

          # Print full service JSON for diagnostics
          echo "--- Koyeb service JSON (full) ---"
          cat /tmp/koyeb_service_resp.json || true

          # Try listing recent deployments to capture permissions/visibility
          echo "Checking service deployments (permissions test)"
          DEPLOYMENTS_CODE=$(curl -s -o /tmp/koyeb_deployments.json -w "%{http_code}" \
            -H "Authorization: Bearer $KOYEB_API_KEY" \
            "https://app.koyeb.com/v1/services/$KOYEB_SERVICE_ID/deployments")
          echo "Deployments list HTTP code: $DEPLOYMENTS_CODE"
          echo "--- Deployments JSON ---"
          cat /tmp/koyeb_deployments.json || true

          # If the service is GitHub-sourced (autodeploy), skip CI-triggered API deploy
          # to avoid API 404s for services managed by the UI/source builder.
          # Check both .source.type (older API format) and .state.auto_release (current autodeploy format)
          SOURCE_TYPE=$(jq -r '.service.source.type // empty' /tmp/koyeb_service_resp.json)
          AUTO_RELEASE_REPO=$(jq -r '.service.state.auto_release.groups[0].repository // empty' /tmp/koyeb_service_resp.json)
          
          echo "Koyeb service source.type: $SOURCE_TYPE"
          echo "Koyeb service auto_release.repository: $AUTO_RELEASE_REPO"
          
          if [ -n "$AUTO_RELEASE_REPO" ]; then
            echo "Service is configured for auto-release from repository: $AUTO_RELEASE_REPO"
            echo "Skipping CI API deploy. Koyeb will build and deploy from the GitHub repository."
            exit 0
          fi
          
          if [ "$SOURCE_TYPE" = "github" ] || [ "$SOURCE_TYPE" = "git" ] || [ "$SOURCE_TYPE" = "github_repo" ]; then
            echo "Service uses GitHub source/autodeploy; skipping CI API deploy. Koyeb will build/deploy from the repository."
            exit 0
          fi

          # Try deploy with retries; capture response body and HTTP code for diagnostics
          MAX_ATTEMPTS=5
          ATTEMPT=0
          PAYLOAD=$(jq -n --arg img "$IMAGE" '{image:$img, strategy:"ROLLING"}')
          while [ "$ATTEMPT" -lt "$MAX_ATTEMPTS" ]; do
            ATTEMPT=$((ATTEMPT+1))
            echo "Deploy attempt $ATTEMPT/$MAX_ATTEMPTS"
            # Use verbose/headers capture for the POST so we get more context
            DEPLOY_CODE=$(curl -s -D /tmp/koyeb_deploy_headers.txt -o /tmp/koyeb_deploy_resp.json -w "%{http_code}" \
              -H "Authorization: Bearer $KOYEB_API_KEY" \
              -H "Content-Type: application/json" \
              -X POST "https://app.koyeb.com/v1/services/$KOYEB_SERVICE_ID/deploy" \
              -d "$PAYLOAD")
            echo "Deploy HTTP code: $DEPLOY_CODE"
            echo "--- Deploy response headers ---"
            sed -n '1,200p' /tmp/koyeb_deploy_headers.txt || true
            echo "--- Deploy response body ---"
            cat /tmp/koyeb_deploy_resp.json || true
            if [ "$DEPLOY_CODE" -ge 200 -a "$DEPLOY_CODE" -lt 300 ]; then
              echo "Deploy succeeded."
              break
            fi
            # If the service isn't found, abort early (likely wrong ID)
            if [ "$DEPLOY_CODE" -eq 404 ]; then
              echo "Received 404 when deploying to Koyeb. This typically means the service ID is invalid or missing permissions."
              echo "Check KOYEB_SERVICE_ID and KOYEB_API_KEY repository secrets and the service's existence."
              exit 1
            fi
            # For other transient errors, wait and retry
            sleep 5
          done
          if [ "$ATTEMPT" -ge "$MAX_ATTEMPTS" ]; then
            echo "Deploy failed after $MAX_ATTEMPTS attempts. See above response bodies for details."
            exit 1
          fi
