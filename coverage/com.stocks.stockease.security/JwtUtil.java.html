<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JwtUtil.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">StockEase</a> &gt; <a href="index.source.html" class="el_package">com.stocks.stockease.security</a> &gt; <span class="el_source">JwtUtil.java</span></div><h1>JwtUtil.java</h1><pre class="source lang-java linenums">package com.stocks.stockease.security;

import java.security.Key;
import java.util.Date;
import java.util.function.Function;

import org.springframework.stereotype.Component;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.JwtException;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.security.Keys;

/**
 * JWT token generation, validation, and claims extraction utility.
 * 
 * Handles all JWT operations including token generation with user claims,
 * cryptographic validation, and claim extraction. Uses HMAC-SHA256 for
 * token signing and 10-hour expiration for security balance.
 * 
 * @author Team StockEase
 * @version 1.0
 * @since 2025-01-01
 */
@Component
<span class="nc" id="L27">public class JwtUtil {</span>

    /**
     * Secret key for HMAC-SHA256 token signing.
     * SECURITY NOTE: In production, move to environment variables or secure vault
     * (do NOT hardcode in source). Must be at least 256 bits for HS256.
     */
    private static final String SECRET_KEY = &quot;your-secret-key-which-must-be-very-secure-and-long&quot;;

    /**
     * JWT expiration time in milliseconds (10 hours = 36,000,000 ms).
     * After this duration, token is invalid. Clients must re-authenticate to obtain new token.
     * Balance: Long enough for user sessions, short enough for security (limited damage if compromised).
     */
    private static final long EXPIRATION_TIME = 1000 * 60 * 60 * 10;

    /**
     * Derived HMAC signing key. Initialized from SECRET_KEY.
     * Used for both token generation and validation (signature verification).
     * Must be at least 256 bits for HS256 algorithm.
     */
<span class="nc" id="L48">    private final Key key = Keys.hmacShaKeyFor(SECRET_KEY.getBytes());</span>

    /**
     * Generates signed JWT token for authenticated user.
     * 
     * Creates a new token with embedded username (subject) and role (custom claim).
     * Token is signed with HMAC-SHA256 algorithm and includes expiration timestamp.
     * Token becomes invalid after 10 hours or if signature is tampered with.
     * 
     * @param username authenticated user's username (becomes JWT &quot;sub&quot; claim)
     * @param role user's authorization role (custom &quot;role&quot; claim: ADMIN or USER)
     * @return compact signed JWT token string (base64url encoded)
     */
    public String generateToken(String username, String role) {
<span class="nc" id="L62">        return Jwts.builder()</span>
                // Subject: username used for authentication on subsequent requests
<span class="nc" id="L64">                .setSubject(username)</span>
                // Custom claim: role used for authorization (@PreAuthorize checks)
<span class="nc" id="L66">                .claim(&quot;role&quot;, role)</span>
                // Standard claims: issued and expiration timestamps
<span class="nc" id="L68">                .setIssuedAt(new Date())</span>
<span class="nc" id="L69">                .setExpiration(new Date(System.currentTimeMillis() + EXPIRATION_TIME))</span>
                // Sign with HMAC-SHA256 using derived key
<span class="nc" id="L71">                .signWith(key, SignatureAlgorithm.HS256)</span>
                // Compact serialization: header.payload.signature
<span class="nc" id="L73">                .compact();</span>
    }

    /**
     * Validates JWT token signature and expiration.
     * 
     * Cryptographically verifies token signature to ensure tampering hasn't occurred.
     * Also validates expiration timestamp. Token is INVALID if signature tampered
     * or expiration time exceeded.
     * 
     * @param token JWT token string to validate
     * @return true if signature valid and not expired; false if tampered or expired
     */
    public boolean validateToken(String token) {
        try {
            // parseClaimsJws() verifies signature and expiration
            // Throws JwtException if any validation fails
<span class="nc" id="L90">            Jwts.parserBuilder().setSigningKey(key).build().parseClaimsJws(token);</span>
<span class="nc" id="L91">            return true;</span>
<span class="nc" id="L92">        } catch (JwtException e) {</span>
            // Catch all JWT errors: signature mismatch, expiration, malformed, etc.
<span class="nc" id="L94">            return false;</span>
        }
    }

    /**
     * Extracts specific claim from token using resolver function.
     * 
     * Generic method to extract any claim from token by applying resolver function.
     * First validates and parses token, then applies resolver to extracted Claims object.
     * 
     * @param token JWT token string
     * @param claimsResolver function to extract desired claim (e.g., Claims::getSubject)
     * @return extracted claim of specified type
     */
    public &lt;T&gt; T extractClaim(String token, Function&lt;Claims, T&gt; claimsResolver) {
        // Parse token and extract all claims (validates signature)
<span class="nc" id="L110">        final Claims claims = extractAllClaims(token);</span>
        // Apply resolver function to extract desired claim
<span class="nc" id="L112">        return claimsResolver.apply(claims);</span>
    }

    /**
     * Extracts all claims from token.
     * 
     * Internal method that parses and validates token, returning all embedded claims.
     * Token must have valid signature; thrown JwtException if signature invalid.
     * 
     * @param token JWT token string
     * @return Claims object with all embedded claims (subject, role, timestamps, etc.)
     */
    private Claims extractAllClaims(String token) {
        // parseClaimsJws() validates signature and returns signed claims
<span class="nc" id="L126">        return Jwts.parserBuilder().setSigningKey(key).build().parseClaimsJws(token).getBody();</span>
    }

    /**
     * Extracts username (subject claim) from token.
     * 
     * Convenience method to extract JWT &quot;sub&quot; claim (username from login).
     * 
     * @param token JWT token string
     * @return username string
     */
    public String extractUsername(String token) {
<span class="nc" id="L138">        return extractClaim(token, Claims::getSubject);</span>
    }

    /**
     * Extracts role (custom claim) from token.
     * 
     * Convenience method to extract custom &quot;role&quot; claim embedded during token generation.
     * Returns ADMIN or USER role for authorization decisions.
     * 
     * @param token JWT token string
     * @return role string (ADMIN or USER)
     */
    public String extractRole(String token) {
        // Get custom &quot;role&quot; claim as String
<span class="nc" id="L152">        return extractClaim(token, claims -&gt; claims.get(&quot;role&quot;, String.class));</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>