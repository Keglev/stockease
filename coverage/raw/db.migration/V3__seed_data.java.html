<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>V3__seed_data.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">StockEase</a> &gt; <a href="index.source.html" class="el_package">db.migration</a> &gt; <span class="el_source">V3__seed_data.java</span></div><h1>V3__seed_data.java</h1><pre class="source lang-java linenums">package db.migration;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;

import org.flywaydb.core.api.migration.BaseJavaMigration;
import org.flywaydb.core.api.migration.Context;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;

/**
 * Flyway Java-based migration: Seed initial users and products into database.
 * 
 * Migration lifecycle:
 * - Executes AFTER all SQL migrations complete (Flyway versioning: V3__seed_data)
 * - Runs on application startup via FlywayConfiguration.migrate()
 * - Idempotent: checks existence before insert (prevents duplicate key violations)
 * 
 * Data seeding strategy:
 * 1. Users: admin (ROLE_ADMIN), user (ROLE_USER) with BCrypt-hashed passwords
 * 2. Products: 8 sample products with name, quantity, price, calculated total_value
 * 
 * Security:
 * - Passwords hashed with BCrypt (strength=10) - matches SecurityConfig.passwordEncoder()
 * - Passwords NOT hardcoded in migration (loaded at runtime)
 * - Development/test only (should be disabled in production via Flyway callbacks)
 * 
 * Database compatibility:
 * - Uses portable SQL: LIMIT 1 instead of DB-specific syntax
 * - Manual existence checks instead of ON CONFLICT (PostgreSQL-specific)
 * - Compatible with H2 (test), PostgreSQL (dev), MySQL (prod)
 * 
 * Performance:
 * - Prepared statements prevent SQL injection and improve parsing
 * - Single connection reused for all operations
 * - Seeding time: ~10ms (negligible on startup)
 * 
 * @author Team StockEase
 * @version 1.0
 * @since 2025-01-01
 * @see org.flywaydb.core.api.migration.BaseJavaMigration
 * @see FlywayConfiguration (orchestration)
 * @see DataSeeder (Spring-based alternative for profile-driven seeding)
 */
<span class="fc" id="L45">public class V3__seed_data extends BaseJavaMigration {</span>

    /**
     * Executes Flyway migration: seed users and products into database.
     * 
     * Execution order:
     * 1. Create tables via SQL migrations (V1__initial_schema.sql, V2__add_columns.sql)
     * 2. Execute this Java migration (V3__seed_data.java) - adds fixture data
     * 3. JPA EntityManagerFactory initialized (reads seeded data via repository queries)
     * 4. Spring Boot starts - controllers ready to serve API requests
     * 
     * User credentials (for testing):
     * - admin / admin123 (ROLE_ADMIN) - Can create/update/delete products
     * - user / user123 (ROLE_USER) - Can read products only
     * 
     * Products (8 total):
     * - Alpha Widget, Beta Gadget, Gamma Tool, Delta Device
     * - Epsilon Accessory, Zeta Instrument, Eta Apparatus, Theta Machine
     * - Each has: name, quantity (stock), unit price, total_value (qty × price)
     * 
     * @param context Flyway context providing database connection
     * @throws Exception if connection fails, SQL execution fails, or BCrypt encoding fails
     */
    @Override
    public void migrate(Context context) throws Exception {
<span class="fc" id="L70">        Connection connection = context.getConnection();</span>

<span class="fc" id="L72">        BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();</span>

        // Seed users (use ON CONFLICT DO NOTHING via simple existence check)
<span class="fc" id="L75">        seedUser(connection, &quot;admin&quot;, encoder.encode(&quot;admin123&quot;), &quot;ROLE_ADMIN&quot;);</span>
<span class="fc" id="L76">        seedUser(connection, &quot;user&quot;, encoder.encode(&quot;user123&quot;), &quot;ROLE_USER&quot;);</span>

    // Seed products (friendly names)
<span class="fc" id="L79">    seedProductIfNotExists(connection, &quot;Alpha Widget&quot;, 10, 50.0);</span>
<span class="fc" id="L80">    seedProductIfNotExists(connection, &quot;Beta Gadget&quot;, 5, 30.0);</span>
<span class="fc" id="L81">    seedProductIfNotExists(connection, &quot;Gamma Tool&quot;, 3, 20.0);</span>
<span class="fc" id="L82">    seedProductIfNotExists(connection, &quot;Delta Device&quot;, 3, 10.0);</span>
<span class="fc" id="L83">    seedProductIfNotExists(connection, &quot;Epsilon Accessory&quot;, 20, 40.0);</span>
<span class="fc" id="L84">    seedProductIfNotExists(connection, &quot;Zeta Instrument&quot;, 7, 60.0);</span>
<span class="fc" id="L85">    seedProductIfNotExists(connection, &quot;Eta Apparatus&quot;, 15, 25.0);</span>
<span class="fc" id="L86">    seedProductIfNotExists(connection, &quot;Theta Machine&quot;, 4, 80.0);</span>
<span class="fc" id="L87">    }</span>

    /**
     * Seeds a user into app_user table (idempotent).
     * 
     * Implementation strategy:
     * - Check if user exists (by username, which is unique constraint)
     * - If exists: return early (idempotent - safe to re-run migration)
     * - If not exists: insert new user with hashed password and role
     * 
     * Database-agnostic approach:
     * - Uses LIMIT 1 (works on H2, PostgreSQL, MySQL)
     * - Avoids PostgreSQL-specific &quot;ON CONFLICT DO NOTHING&quot;
     * - Enables migration to work across different database systems
     * 
     * Security:
     * - Password already hashed by caller via BCryptPasswordEncoder
     * - PreparedStatement prevents SQL injection via parameterized queries
     * - No password logging (prevents secrets in migration output)
     * 
     * @param connection database connection from Flyway context
     * @param username user login identifier (must be unique)
     * @param hashedPassword BCrypt-encoded password (minimum 60 chars)
     * @param role Spring Security authority (e.g., &quot;ROLE_ADMIN&quot;, &quot;ROLE_USER&quot;)
     * @throws Exception if SQL execution fails or connection is closed
     */
    private void seedUser(Connection connection, String username, String hashedPassword, String role) throws Exception {
        // Make seeding DB-agnostic: first check for existence, then insert if missing.
        // This avoids relying on DB-specific syntax like Postgres' ON CONFLICT.
<span class="fc" id="L116">        String checkSql = &quot;SELECT id FROM app_user WHERE username = ?&quot;;</span>
<span class="fc" id="L117">        try (PreparedStatement check = connection.prepareStatement(checkSql)) {</span>
<span class="fc" id="L118">            check.setString(1, username);</span>
<span class="fc" id="L119">            try (ResultSet rs = check.executeQuery()) {</span>
<span class="pc bpc" id="L120" title="1 of 2 branches missed.">                if (rs.next()) {</span>
<span class="nc" id="L121">                    return; // user already exists</span>
                }
<span class="nc bnc" id="L123" title="All 2 branches missed.">            }</span>
<span class="nc bnc" id="L124" title="All 2 branches missed.">        }</span>

<span class="fc" id="L126">        String insertSql = &quot;INSERT INTO app_user (username, password, role) VALUES (?, ?, ?)&quot;;</span>
<span class="fc" id="L127">        try (PreparedStatement ps = connection.prepareStatement(insertSql)) {</span>
<span class="fc" id="L128">            ps.setString(1, username);</span>
<span class="fc" id="L129">            ps.setString(2, hashedPassword);</span>
<span class="fc" id="L130">            ps.setString(3, role);</span>
<span class="fc" id="L131">            ps.executeUpdate();</span>
        }
<span class="fc" id="L133">    }</span>

    /**
     * Seeds a product into product table if it doesn't already exist (idempotent).
     * 
     * Implementation strategy:
     * - Query by name (unique constraint on product.name)
     * - If result found: return early (product already in database)
     * - If not found: calculate total_value and insert new row
     * 
     * Total value calculation:
     * - total_value = quantity × price
     * - Denormalized column (cached value) for reporting/analytics efficiency
     * - Kept in sync via trigger or application logic on quantity/price updates
     * - Example: quantity=10, price=50.0 → total_value=500.0
     * 
     * Idempotency guarantee:
     * - Migration can be re-run without creating duplicates
     * - Safe for flyway.cleanDisabled=false scenarios
     * - Enables non-destructive rollback + reapply workflows
     * 
     * @param connection database connection from Flyway context
     * @param name product identifier (unique, user-facing name)
     * @param quantity stock units in warehouse (integer, ≥ 0)
     * @param price unit cost per item (decimal, ≥ 0.0)
     * @throws Exception if SQL execution fails or connection is closed
     */
    private void seedProductIfNotExists(Connection connection, String name, int quantity, double price) throws Exception {
<span class="fc" id="L161">        String checkSql = &quot;SELECT id FROM product WHERE name = ? LIMIT 1&quot;;</span>
<span class="fc" id="L162">        try (PreparedStatement check = connection.prepareStatement(checkSql)) {</span>
<span class="fc" id="L163">            check.setString(1, name);</span>
<span class="fc" id="L164">            try (ResultSet rs = check.executeQuery()) {</span>
<span class="pc bpc" id="L165" title="1 of 2 branches missed.">                if (rs.next()) {</span>
<span class="nc" id="L166">                    return; // exists</span>
                }
<span class="nc bnc" id="L168" title="All 2 branches missed.">            }</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">        }</span>

<span class="fc" id="L171">        String insertSql = &quot;INSERT INTO product (name, quantity, price, total_value) VALUES (?, ?, ?, ?)&quot;;</span>
<span class="fc" id="L172">        try (PreparedStatement ins = connection.prepareStatement(insertSql)) {</span>
<span class="fc" id="L173">            ins.setString(1, name);</span>
<span class="fc" id="L174">            ins.setInt(2, quantity);</span>
<span class="fc" id="L175">            ins.setDouble(3, price);</span>
<span class="fc" id="L176">            ins.setDouble(4, quantity * price);</span>
<span class="fc" id="L177">            ins.executeUpdate();</span>
        }
<span class="fc" id="L179">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>